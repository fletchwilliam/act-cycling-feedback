<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canberra Cycling Infrastructure Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 380px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .control-panel h2 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }
        
        .control-panel h3 {
            font-size: 13px;
            margin: 12px 0 8px 0;
            color: #555;
        }
        
        .file-input-wrapper {
            margin-bottom: 10px;
        }
        
        .file-input-wrapper label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .file-input-wrapper input[type="file"] {
            font-size: 12px;
            width: 100%;
        }
        
        .legend {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
        }
        
        .legend-line {
            width: 30px;
            height: 4px;
            margin-right: 8px;
            border-radius: 2px;
        }
        
        .legend-point {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 50%;
        }
        
        .stats {
            margin-top: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .stats h4 {
            font-size: 13px;
            margin-bottom: 8px;
            color: #333;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }
        
        .stat-value {
            font-weight: 600;
            color: #2196F3;
        }
        
        .layer-toggle {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
        }
        
        .layer-toggle input {
            margin-right: 8px;
        }
        
        .layer-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .layer-controls button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 2px;
            opacity: 0.6;
        }
        
        .layer-controls button:hover {
            opacity: 1;
        }
        
        .popup-content {
            font-size: 12px;
            line-height: 1.5;
            max-width: 250px;
        }
        
        .popup-content strong {
            color: #333;
        }
        
        .popup-content .property {
            margin: 4px 0;
        }
        
        .popup-content .property-label {
            color: #666;
            font-size: 11px;
        }
        
        .instructions {
            font-size: 11px;
            color: #888;
            margin-bottom: 12px;
            padding: 8px;
            background: #f9f9f9;
            border-radius: 4px;
        }
        
        .collapse-btn {
            position: absolute;
            top: 10px;
            right: 400px;
            z-index: 1000;
            background: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            font-size: 12px;
        }
        
        .collapse-btn:hover {
            background: #f0f0f0;
        }
        
        .control-panel.collapsed {
            display: none;
        }
        
        .collapse-btn.collapsed {
            right: 10px;
        }
        
        .custom-layer-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            margin: 4px 0;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .custom-layer-item .layer-info {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }
        
        .custom-layer-item .color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.2);
        }
        
        .custom-layer-item .layer-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .add-layer-section {
            margin-top: 15px;
            padding: 12px;
            background: #e8f5e9;
            border-radius: 6px;
        }
        
        .add-layer-section h3 {
            margin-top: 0;
            color: #2e7d32;
        }
        
        .add-layer-form {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .add-layer-form input[type="text"],
        .add-layer-form select {
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .add-layer-form input[type="color"] {
            width: 50px;
            height: 30px;
            padding: 0;
            border: none;
            cursor: pointer;
        }
        
        .form-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .form-row label {
            font-size: 11px;
            color: #666;
            min-width: 50px;
        }
        
        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover {
            background: #45a049;
        }
        
        .btn-sm {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        .btn-secondary {
            background: #9e9e9e;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #757575;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
            padding: 4px 8px;
            font-size: 11px;
        }
        
        .btn-danger:hover {
            background: #d32f2f;
        }
        
        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
        }
        
        .preset-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .preset-btn:hover {
            background: #bbdefb;
        }
        
        .section-divider {
            border-top: 1px solid #ddd;
            margin: 15px 0;
            padding-top: 15px;
        }
        
        #customLayersList {
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* Filter panel styles */
        .filter-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .filter-panel h2 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #333;
            border-bottom: 2px solid #2196F3;
            padding-bottom: 8px;
        }
        
        .filter-panel h3 {
            font-size: 13px;
            margin: 12px 0 8px 0;
            color: #555;
        }
        
        .filter-panel.collapsed {
            display: none;
        }
        
        .filter-toggle-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 999;
            background: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            font-size: 12px;
        }
        
        .filter-toggle-btn:hover {
            background: #f0f0f0;
        }
        
        .filter-toggle-btn.panel-open {
            left: 340px;
        }
        
        .filter-section {
            margin-bottom: 15px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 6px;
        }
        
        .filter-section h4 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-group {
            margin-bottom: 10px;
        }
        
        .filter-group label {
            display: block;
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .filter-group select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .filter-group input[type="text"],
        .filter-group input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .filter-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .filter-row input {
            flex: 1;
        }
        
        .active-filters {
            margin-top: 10px;
            padding: 8px;
            background: #fff3e0;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .active-filters .filter-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: #ff9800;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            margin: 2px;
            font-size: 10px;
        }
        
        .active-filters .filter-tag button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
            line-height: 1;
        }
        
        .filter-count {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }
        
        .no-data-msg {
            color: #888;
            font-style: italic;
            font-size: 11px;
            padding: 10px;
        }
        
        .checkbox-group {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            background: white;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 3px 0;
            font-size: 11px;
        }
        
        .checkbox-item input {
            margin: 0;
        }
        
        .checkbox-item label {
            margin: 0;
            cursor: pointer;
        }
        
        .select-all-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid #eee;
        }
        
        .select-all-row button {
            font-size: 10px;
            padding: 2px 6px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .select-all-row button:hover {
            background: #bbdefb;
        }
        
        .checkbox-item input[type="color"] {
            width: 24px;
            height: 18px;
            padding: 0;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            margin-left: auto;
        }
        
        .filter-color-mode {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
            padding: 6px 8px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 10px;
        }
        
        .filter-color-mode label {
            color: #1565c0;
        }
        
        .filter-color-mode input[type="checkbox"] {
            margin: 0;
        }
        
        .apply-colors-btn {
            width: 100%;
            margin-top: 8px;
            padding: 6px;
            font-size: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .apply-colors-btn:hover {
            background: #43a047;
        }
        
        /* Feedback system styles */
        .feedback-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.25);
            width: 320px;
            display: none;
        }
        
        .feedback-panel.visible {
            display: block;
        }
        
        .feedback-panel h3 {
            font-size: 14px;
            margin: 0 0 12px 0;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #2196F3;
            padding-bottom: 8px;
        }
        
        .feedback-panel .close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 0;
            line-height: 1;
        }
        
        .feedback-instructions {
            font-size: 11px;
            color: #666;
            background: #e3f2fd;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 12px;
        }
        
        .feedback-location {
            font-size: 11px;
            color: #333;
            background: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 12px;
        }
        
        .feedback-location strong {
            color: #1976D2;
        }
        
        .feedback-rating {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .feedback-rating button {
            flex: 1;
            padding: 15px;
            font-size: 24px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .feedback-rating button:hover {
            transform: scale(1.05);
        }
        
        .feedback-rating button.thumbs-up:hover,
        .feedback-rating button.thumbs-up.selected {
            border-color: #4CAF50;
            background: #e8f5e9;
        }
        
        .feedback-rating button.thumbs-down:hover,
        .feedback-rating button.thumbs-down.selected {
            border-color: #f44336;
            background: #ffebee;
        }
        
        .feedback-form-group {
            margin-bottom: 12px;
        }
        
        .feedback-form-group label {
            display: block;
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .feedback-form-group select,
        .feedback-form-group input,
        .feedback-form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .feedback-form-group textarea {
            resize: vertical;
            min-height: 60px;
        }
        
        .feedback-actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }
        
        .feedback-actions button {
            flex: 1;
            padding: 10px;
            font-size: 12px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }
        
        .feedback-actions button.cancel {
            background: #f5f5f5;
            color: #666;
        }
        
        .feedback-actions button.send {
            background: #2196F3;
            color: white;
        }
        
        .feedback-actions button.send:hover {
            background: #1976D2;
        }
        
        .feedback-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Feedback marker popup */
        .feedback-popup {
            min-width: 200px;
        }
        
        .feedback-popup .rating {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .feedback-popup .category {
            font-size: 11px;
            color: #666;
            background: #f5f5f5;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 8px;
        }
        
        .feedback-popup .comment {
            font-size: 12px;
            color: #333;
            margin-bottom: 8px;
            padding: 8px;
            background: #fafafa;
            border-radius: 4px;
        }
        
        .feedback-popup .meta {
            font-size: 10px;
            color: #999;
        }
        
        /* Selection tool styles */
        .selection-toolbar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .selection-toolbar button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }
        
        .selection-toolbar button:hover {
            background: #f5f5f5;
        }
        
        .selection-toolbar button.active {
            background: #2196F3;
            color: white;
            border-color: #1976D2;
        }
        
        .selection-toolbar .divider {
            width: 1px;
            height: 24px;
            background: #ddd;
        }
        
        .selection-toolbar .status {
            font-size: 11px;
            color: #666;
            padding: 0 8px;
        }
        
        /* Analysis panel styles */
        .analysis-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.25);
            max-width: 600px;
            max-height: 50vh;
            overflow-y: auto;
            display: none;
        }
        
        .analysis-panel.visible {
            display: block;
        }
        
        .analysis-panel h3 {
            font-size: 14px;
            margin: 0 0 12px 0;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #ff9800;
            padding-bottom: 8px;
        }
        
        .analysis-panel .close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 0;
            line-height: 1;
        }
        
        .analysis-panel .close-btn:hover {
            color: #333;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .analysis-card {
            background: #f9f9f9;
            border-radius: 6px;
            padding: 12px;
        }
        
        .analysis-card h4 {
            font-size: 12px;
            margin: 0 0 8px 0;
            color: #555;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .analysis-card .color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .analysis-card .metric {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 12px;
        }
        
        .analysis-card .metric-value {
            font-weight: 600;
            color: #2196F3;
        }
        
        .analysis-card .breakdown {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e0e0e0;
        }
        
        .analysis-card .breakdown-title {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .analysis-card .breakdown-item {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            padding: 2px 0;
        }
        
        .analysis-summary {
            background: #e3f2fd;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .analysis-summary .total {
            font-size: 24px;
            font-weight: 700;
            color: #1976D2;
        }
        
        .analysis-summary .label {
            font-size: 12px;
            color: #666;
        }
        
        .analysis-actions {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #ddd;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .analysis-actions button {
            padding: 6px 12px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
        }
        
        .analysis-actions button:hover {
            background: #f5f5f5;
        }
        
        .analysis-actions button.primary {
            background: #4CAF50;
            color: white;
            border-color: #43a047;
        }
        
        .analysis-actions button.primary:hover {
            background: #43a047;
        }
        
        /* Selection rectangle style */
        .leaflet-selection-rect {
            border: 2px dashed #2196F3;
            background: rgba(33, 150, 243, 0.1);
        }
        
        /* Highlighted selected features */
        .selected-feature {
            stroke: #ff9800 !important;
            stroke-width: 4 !important;
        }
        
        /* Layer styling panel */
        .style-panel {
            position: absolute;
            top: 60px;
            right: 10px;
            z-index: 1001;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.25);
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
        .style-panel.visible {
            display: block;
        }
        
        .style-panel h3 {
            font-size: 14px;
            margin: 0 0 12px 0;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #9c27b0;
            padding-bottom: 8px;
        }
        
        .style-panel .close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 0;
            line-height: 1;
        }
        
        .style-section {
            margin-bottom: 15px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 6px;
        }
        
        .style-section h4 {
            font-size: 12px;
            margin: 0 0 10px 0;
            color: #555;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .style-section h4 .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
        
        .style-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }
        
        .style-row label {
            font-size: 11px;
            color: #666;
            min-width: 70px;
        }
        
        .style-row input[type="color"] {
            width: 40px;
            height: 28px;
            padding: 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .style-row input[type="range"] {
            flex: 1;
            height: 6px;
            cursor: pointer;
        }
        
        .style-row input[type="number"] {
            width: 60px;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .style-row select {
            flex: 1;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .style-row .value-display {
            font-size: 11px;
            color: #333;
            min-width: 35px;
            text-align: right;
        }
        
        .style-row input[type="checkbox"] {
            margin: 0;
        }
        
        .style-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
        }
        
        .style-presets button {
            padding: 4px 8px;
            font-size: 10px;
            background: #f3e5f5;
            border: 1px solid #ce93d8;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .style-presets button:hover {
            background: #e1bee7;
        }
        
        .map-style-section {
            margin-bottom: 15px;
            padding: 12px;
            background: #e3f2fd;
            border-radius: 6px;
        }
        
        .map-style-section h4 {
            font-size: 12px;
            margin: 0 0 10px 0;
            color: #1565c0;
        }
        
        .basemap-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }
        
        .basemap-option {
            padding: 8px;
            font-size: 11px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        
        .basemap-option:hover {
            border-color: #90caf9;
        }
        
        .basemap-option.active {
            border-color: #1976D2;
            background: #e3f2fd;
        }
        
        .style-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .style-actions button {
            flex: 1;
            padding: 8px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
        }
        
        .style-actions button:hover {
            background: #f5f5f5;
        }
        
        .style-actions button.primary {
            background: #9c27b0;
            color: white;
            border-color: #7b1fa2;
        }
        
        .style-actions button.primary:hover {
            background: #7b1fa2;
        }
        
        .style-toggle-btn {
            position: absolute;
            top: 60px;
            right: 10px;
            z-index: 1000;
            background: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            font-size: 12px;
        }
        
        .style-toggle-btn:hover {
            background: #f0f0f0;
        }
        
        .control-panel {
            top: 100px;
        }
        
        .collapse-btn {
            top: 100px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Style Toggle Button -->
    <button class="style-toggle-btn" id="styleToggleBtn" onclick="toggleStylePanel()">üé® Style Layers</button>
    
    <!-- Layer Styling Panel -->
    <div class="style-panel" id="stylePanel">
        <h3>
            üé® Layer Styling
            <button class="close-btn" onclick="toggleStylePanel()">√ó</button>
        </h3>
        
        <!-- Map Background Options -->
        <div class="map-style-section">
            <h4>üó∫Ô∏è Base Map</h4>
            <div class="basemap-options">
                <div class="basemap-option active" onclick="setBasemap('streets')" id="basemap-streets">Streets</div>
                <div class="basemap-option" onclick="setBasemap('light')" id="basemap-light">Light</div>
                <div class="basemap-option" onclick="setBasemap('dark')" id="basemap-dark">Dark</div>
                <div class="basemap-option" onclick="setBasemap('satellite')" id="basemap-satellite">Satellite</div>
                <div class="basemap-option" onclick="setBasemap('topo')" id="basemap-topo">Terrain</div>
                <div class="basemap-option" onclick="setBasemap('none')" id="basemap-none">None</div>
            </div>
        </div>
        
        <!-- Quick Presets -->
        <div style="margin-bottom: 15px;">
            <label style="font-size: 11px; color: #666; display: block; margin-bottom: 6px;">Quick Presets:</label>
            <div class="style-presets">
                <button onclick="applyStylePreset('default')">Default</button>
                <button onclick="applyStylePreset('highContrast')">High Contrast</button>
                <button onclick="applyStylePreset('subtle')">Subtle</button>
                <button onclick="applyStylePreset('thick')">Thick Lines</button>
                <button onclick="applyStylePreset('thin')">Thin Lines</button>
                <button onclick="applyStylePreset('neon')">Neon</button>
            </div>
        </div>
        
        <!-- Layer-specific styles -->
        <div id="layerStylesList">
            <p style="color: #888; font-style: italic; font-size: 11px; padding: 10px;">Load datasets to customize their styles</p>
        </div>
        
        <div class="style-actions">
            <button onclick="resetAllStyles()">Reset All</button>
            <button onclick="applyAllStyles()" class="primary">Apply Styles</button>
        </div>
    </div>
    
    <!-- Selection Toolbar (Top center) -->
    <div class="selection-toolbar" id="selectionToolbar">
        <button id="panModeBtn" class="active" onclick="setMode('pan')" title="Pan/Navigate">
            üñêÔ∏è Pan
        </button>
        <button id="selectModeBtn" onclick="setMode('select')" title="Select features by drawing a rectangle">
            ‚¨ö Select Area
        </button>
        <button id="feedbackModeBtn" onclick="setMode('feedback')" title="Click on a path to leave feedback">
            üí¨ Feedback
        </button>
        <div class="divider"></div>
        <button onclick="clearSelection()" title="Clear current selection">
            ‚úï Clear
        </button>
        <span class="status" id="selectionStatus">Click "Select Area" to begin</span>
    </div>
    
    <!-- Feedback Panel (Bottom left) -->
    <div class="feedback-panel" id="feedbackPanel">
        <h3>
            üí¨ Leave Feedback
            <button class="close-btn" onclick="closeFeedbackPanel()">√ó</button>
        </h3>
        
        <div class="feedback-instructions">
            Click on any path to select a location for your feedback.
        </div>
        
        <div class="feedback-location" id="feedbackLocation" style="display: none;">
            <strong>Location:</strong> <span id="feedbackLocationText"></span>
        </div>
        
        <div id="feedbackForm" style="display: none;">
            <div class="feedback-rating">
                <button type="button" class="thumbs-up" onclick="setFeedbackRating('good')" title="Good">üëç</button>
                <button type="button" class="thumbs-down" onclick="setFeedbackRating('bad')" title="Bad">üëé</button>
            </div>
            
            <div class="feedback-form-group">
                <label>Reason for rating *</label>
                <select id="feedbackCategory">
                    <option value="">-- Select a reason --</option>
                    <option value="surface">Surface Quality</option>
                    <option value="safety">Safety Concern</option>
                    <option value="lighting">Lighting</option>
                    <option value="other">Other</option>
                </select>
            </div>
            
            <div class="feedback-form-group">
                <label>Comment (optional)</label>
                <textarea id="feedbackComment" placeholder="Add any additional details..."></textarea>
            </div>
            
            <div class="feedback-form-group">
                <label>Your name (optional)</label>
                <input type="text" id="feedbackName" placeholder="Name">
            </div>
            
            <div class="feedback-form-group">
                <label>Your email (optional)</label>
                <input type="email" id="feedbackEmail" placeholder="email@example.com">
            </div>
            
            <div class="feedback-actions">
                <button class="cancel" onclick="resetFeedbackForm()">Cancel</button>
                <button class="send" id="sendFeedbackBtn" onclick="downloadFeedback()" disabled>üì• Download Feedback</button>
            </div>
        </div>
    </div>
    
    <!-- Analysis Panel (Bottom center) -->
    <div class="analysis-panel" id="analysisPanel">
        <h3>
            üìä Selection Analysis
            <button class="close-btn" onclick="closeAnalysisPanel()">√ó</button>
        </h3>
        <div id="analysisContent">
            <!-- Analysis content will be inserted here -->
        </div>
    </div>
    
    <!-- Filter Panel (Left side) -->
    <button class="filter-toggle-btn panel-open" id="filterToggleBtn" onclick="toggleFilterPanel()">üîç Filters</button>
    
    <div class="filter-panel" id="filterPanel">
        <h2>üîç Filter Data</h2>
        
        <div id="filterContent">
            <p class="no-data-msg">Load datasets to enable filtering</p>
        </div>
    </div>
    
    <!-- Control Panel (Right side) -->
    <button class="collapse-btn" onclick="togglePanel()">‚ò∞ Panel</button>
    
    <div class="control-panel" id="controlPanel">
        <h2>üö¥ Canberra Infrastructure Map</h2>
        
        <div class="instructions">
            Load GeoJSON files to visualize cycling infrastructure, pedestrian crossings, and other spatial data.
        </div>
        
        <!-- Core datasets section -->
        <h3>Core Datasets</h3>
        <div class="file-input-wrapper">
            <label>Community Path Assets:</label>
            <input type="file" id="pathsFile" accept=".geojson,.json" onchange="loadCoreDataset(this, 'paths')">
        </div>
        
        <div class="file-input-wrapper">
            <label>On Road Cycle Lanes:</label>
            <input type="file" id="lanesFile" accept=".geojson,.json" onchange="loadCoreDataset(this, 'lanes')">
        </div>
        
        <!-- Add custom layer section -->
        <div class="add-layer-section">
            <h3>‚ûï Add Custom Layer</h3>
            <div class="preset-buttons">
                <button class="preset-btn" onclick="applyPreset('crossings')">üö∂ Crossings</button>
                <button class="preset-btn" onclick="applyPreset('bikeracks')">üÖøÔ∏è Bike Racks</button>
                <button class="preset-btn" onclick="applyPreset('traffic')">üö¶ Traffic Lights</button>
                <button class="preset-btn" onclick="applyPreset('custom')">üìç Custom</button>
            </div>
            <div class="add-layer-form">
                <input type="text" id="layerName" placeholder="Layer name (e.g., Pedestrian Crossings)">
                <div class="form-row">
                    <label>Color:</label>
                    <input type="color" id="layerColor" value="#e91e63">
                    <label>Type:</label>
                    <select id="layerType">
                        <option value="auto">Auto-detect</option>
                        <option value="point">Points</option>
                        <option value="line">Lines</option>
                        <option value="polygon">Polygons</option>
                    </select>
                </div>
                <input type="file" id="customLayerFile" accept=".geojson,.json">
                <button class="btn btn-primary" onclick="addCustomLayer()">Add Layer</button>
            </div>
        </div>
        
        <!-- Load Feedback section -->
        <div class="add-layer-section">
            <h3>üí¨ Load Feedback</h3>
            <p style="font-size: 11px; color: #666; margin-bottom: 8px;">Load feedback GeoJSON files to display on the map</p>
            <input type="file" id="feedbackFile" accept=".geojson,.json" multiple onchange="loadFeedbackFiles(this)">
            <div id="feedbackLayerInfo" style="display: none; margin-top: 8px; font-size: 11px; color: #333;"></div>
        </div>
        
        <!-- Layer visibility section -->
        <div class="section-divider">
            <h3>Layer Visibility</h3>
            
            <div class="layer-toggle">
                <input type="checkbox" id="togglePaths" checked onchange="toggleCoreLayer('paths')">
                <label for="togglePaths">Community Paths</label>
            </div>
            <div class="layer-toggle">
                <input type="checkbox" id="toggleLanes" checked onchange="toggleCoreLayer('lanes')">
                <label for="toggleLanes">On Road Cycle Lanes</label>
            </div>
            
            <div id="feedbackLayerControls" style="display: none;"></div>
            
            <h3>Custom Layers</h3>
            <div id="customLayersList">
                <p style="color: #888; font-style: italic; font-size: 11px;">No custom layers added yet</p>
            </div>
        </div>
        
        <!-- Legend -->
        <div class="legend">
            <h3>Legend - Community Paths</h3>
            <div class="legend-item">
                <div class="legend-line" style="background: #e41a1c;"></div>
                <span>Cyclepath</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #377eb8;"></div>
                <span>Separated Cyclepath</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #4daf4a;"></div>
                <span>Footpath</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #984ea3;"></div>
                <span>Shared Path</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #999999;"></div>
                <span>Other</span>
            </div>
            
            <h3>Legend - Cycle Lanes</h3>
            <div class="legend-item">
                <div class="legend-line" style="background: #ff7f00; height: 6px;"></div>
                <span>Green Pavement Paint</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #a65628; height: 6px;"></div>
                <span>Standard Pavement</span>
            </div>
            
            <div id="customLegend"></div>
        </div>
        
        <!-- Statistics -->
        <div class="stats" id="stats">
            <h4>üìä Statistics</h4>
            <p style="color: #888; font-style: italic;">Load data to see statistics</p>
        </div>
    </div>
    
    <script>
        // Initialize map centered on Canberra
        const map = L.map('map').setView([-35.2809, 149.1300], 12);
        
        // Basemap layers
        const basemaps = {
            streets: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }),
            light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/">CARTO</a>'
            }),
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/">CARTO</a>'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; Esri'
            }),
            topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://opentopomap.org">OpenTopoMap</a>'
            }),
            none: null
        };
        
        let currentBasemap = 'streets';
        basemaps.streets.addTo(map);
        
        // Layer styles storage
        let layerStyles = {
            paths: {
                weight: 3,
                opacity: 0.8,
                dashArray: '',
                lineCap: 'round',
                lineJoin: 'round',
                useTypeColors: true,
                singleColor: '#e41a1c'
            },
            lanes: {
                weight: 5,
                opacity: 0.9,
                dashArray: '',
                lineCap: 'round',
                lineJoin: 'round',
                useTypeColors: true,
                singleColor: '#ff7f00'
            }
        };
        
        // Custom layer styles
        let customLayerStyles = {};
        
        // Filter-based coloring
        let filterColors = {
            paths: { enabled: false, field: null, colors: {} },
            lanes: { enabled: false, field: null, colors: {} }
        };
        
        // Default color palettes for auto-assignment
        const colorPalette = [
            '#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00',
            '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5',
            '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f'
        ];
        
        // Core layer storage
        let coreLayers = {
            paths: { layer: null, data: null, filteredData: null, filters: {} },
            lanes: { layer: null, data: null, filteredData: null, filters: {} }
        };
        
        // Custom layers storage
        let customLayers = {};
        let layerIdCounter = 0;
        
        // Selection state
        let selectionMode = 'pan';
        let selectionRect = null;
        let selectionBounds = null;
        let selectedFeatures = {
            paths: [],
            lanes: [],
            custom: {}
        };
        let selectionStartPoint = null;
        let isDrawing = false;
        
        // Color schemes for core layers
        const pathColors = {
            'CYCLEPATH': '#e41a1c',
            'SEPARATED CYCLEPATH': '#377eb8',
            'FOOTPATH': '#4daf4a',
            'SHARED PATH': '#984ea3',
            'DEFAULT': '#999999'
        };
        
        const laneColors = {
            'GREEN PAVEMENT PAINT': '#ff7f00',
            'STANDARD PAVEMENT SURFACE': '#a65628',
            'DEFAULT': '#f781bf'
        };
        
        // Presets for common layer types
        const presets = {
            crossings: { name: 'Pedestrian Crossings', color: '#e91e63', type: 'point' },
            bikeracks: { name: 'Bike Racks', color: '#9c27b0', type: 'point' },
            traffic: { name: 'Traffic Lights', color: '#f44336', type: 'point' },
            custom: { name: '', color: '#2196F3', type: 'auto' }
        };
        
        // Fields to use for filtering (prioritized list)
        const filterableFields = [
            'ASSET_TYPE', 'ASSET_SUB_TYPE', 'PATH_SURFACE', 'SURFACE_TYPE',
            'SUBURB', 'TRAVEL_DIRECTION', 'TRAVEL_RESTRICTION', 'OWNERSHIP',
            'MAINTAINED_BY', 'ROAD_LOCATION_TYPE', 'ADAJCENT_KERB'
        ];
        
        // Numeric fields for range filtering
        const numericFields = ['AVERAGE_WIDTH', 'PATH_LENGTH', 'LENGTH', 'WIDTH'];
        
        // ==================== SELECTION TOOL ====================
        
        function setMode(mode) {
            selectionMode = mode;
            
            document.getElementById('panModeBtn').classList.toggle('active', mode === 'pan');
            document.getElementById('selectModeBtn').classList.toggle('active', mode === 'select');
            document.getElementById('feedbackModeBtn').classList.toggle('active', mode === 'feedback');
            
            if (mode === 'pan') {
                map.dragging.enable();
                map.getContainer().style.cursor = '';
                updateSelectionStatus('Click "Select Area" to begin');
                document.getElementById('feedbackPanel').classList.remove('visible');
            } else if (mode === 'select') {
                map.dragging.disable();
                map.getContainer().style.cursor = 'crosshair';
                updateSelectionStatus('Click and drag to select an area');
                document.getElementById('feedbackPanel').classList.remove('visible');
            } else if (mode === 'feedback') {
                map.dragging.enable();
                map.getContainer().style.cursor = 'pointer';
                updateSelectionStatus('Click on a path to leave feedback');
                document.getElementById('feedbackPanel').classList.add('visible');
                resetFeedbackForm();
            }
        }
        
        function updateSelectionStatus(text) {
            document.getElementById('selectionStatus').textContent = text;
        }
        
        // Mouse events for selection
        map.on('mousedown', function(e) {
            if (selectionMode !== 'select') return;
            
            isDrawing = true;
            selectionStartPoint = e.latlng;
            
            if (selectionRect) {
                map.removeLayer(selectionRect);
            }
        });
        
        map.on('mousemove', function(e) {
            if (!isDrawing || selectionMode !== 'select') return;
            
            const bounds = L.latLngBounds(selectionStartPoint, e.latlng);
            
            if (selectionRect) {
                selectionRect.setBounds(bounds);
            } else {
                selectionRect = L.rectangle(bounds, {
                    color: '#2196F3',
                    weight: 2,
                    fillOpacity: 0.1,
                    dashArray: '5, 5'
                }).addTo(map);
            }
        });
        
        map.on('mouseup', function(e) {
            if (!isDrawing || selectionMode !== 'select') return;
            
            isDrawing = false;
            selectionBounds = L.latLngBounds(selectionStartPoint, e.latlng);
            
            // Perform selection
            performSelection(selectionBounds);
            
            // Switch back to pan mode
            setMode('pan');
        });
        
        function performSelection(bounds) {
            // Clear previous selection
            selectedFeatures = { paths: [], lanes: [], custom: {} };
            
            // Select from core layers
            if (coreLayers.paths.filteredData) {
                selectedFeatures.paths = selectFeaturesInBounds(coreLayers.paths.filteredData.features, bounds);
            }
            
            if (coreLayers.lanes.filteredData) {
                selectedFeatures.lanes = selectFeaturesInBounds(coreLayers.lanes.filteredData.features, bounds);
            }
            
            // Select from custom layers
            for (const [layerId, info] of Object.entries(customLayers)) {
                if (info.filteredData && info.visible) {
                    selectedFeatures.custom[layerId] = selectFeaturesInBounds(info.filteredData.features, bounds);
                }
            }
            
            // Count total selected
            let totalSelected = selectedFeatures.paths.length + selectedFeatures.lanes.length;
            for (const features of Object.values(selectedFeatures.custom)) {
                totalSelected += features.length;
            }
            
            updateSelectionStatus(`${totalSelected} features selected`);
            
            // Show analysis
            if (totalSelected > 0) {
                showAnalysis();
            } else {
                closeAnalysisPanel();
            }
        }
        
        function selectFeaturesInBounds(features, bounds) {
            if (!features) return [];
            
            return features.filter(feature => {
                return featureIntersectsBounds(feature, bounds);
            });
        }
        
        function featureIntersectsBounds(feature, bounds) {
            const geom = feature.geometry;
            if (!geom) return false;
            
            switch (geom.type) {
                case 'Point':
                    return bounds.contains(L.latLng(geom.coordinates[1], geom.coordinates[0]));
                    
                case 'MultiPoint':
                    return geom.coordinates.some(coord => 
                        bounds.contains(L.latLng(coord[1], coord[0]))
                    );
                    
                case 'LineString':
                    return geom.coordinates.some(coord => 
                        bounds.contains(L.latLng(coord[1], coord[0]))
                    );
                    
                case 'MultiLineString':
                    return geom.coordinates.some(line =>
                        line.some(coord => bounds.contains(L.latLng(coord[1], coord[0])))
                    );
                    
                case 'Polygon':
                    return geom.coordinates[0].some(coord =>
                        bounds.contains(L.latLng(coord[1], coord[0]))
                    );
                    
                case 'MultiPolygon':
                    return geom.coordinates.some(poly =>
                        poly[0].some(coord => bounds.contains(L.latLng(coord[1], coord[0])))
                    );
                    
                default:
                    return false;
            }
        }
        
        function clearSelection() {
            if (selectionRect) {
                map.removeLayer(selectionRect);
                selectionRect = null;
            }
            selectionBounds = null;
            selectedFeatures = { paths: [], lanes: [], custom: {} };
            updateSelectionStatus('Selection cleared');
            closeAnalysisPanel();
        }
        
        function closeAnalysisPanel() {
            document.getElementById('analysisPanel').classList.remove('visible');
        }
        
        function showAnalysis() {
            const panel = document.getElementById('analysisPanel');
            const content = document.getElementById('analysisContent');
            
            let html = '';
            
            // Calculate totals
            let totalFeatures = selectedFeatures.paths.length + selectedFeatures.lanes.length;
            let totalLength = 0;
            
            for (const features of Object.values(selectedFeatures.custom)) {
                totalFeatures += features.length;
            }
            
            // Summary
            html += `<div class="analysis-summary">
                <span class="total">${totalFeatures}</span>
                <span class="label"> features selected in area</span>
            </div>`;
            
            html += '<div class="analysis-grid">';
            
            // Paths analysis
            if (selectedFeatures.paths.length > 0) {
                html += buildAnalysisCard('Community Paths', selectedFeatures.paths, '#4CAF50', {
                    lengthField: 'PATH_LENGTH',
                    widthField: 'AVERAGE_WIDTH',
                    typeField: 'ASSET_SUB_TYPE',
                    surfaceField: 'PATH_SURFACE',
                    suburbField: 'SUBURB'
                });
            }
            
            // Lanes analysis
            if (selectedFeatures.lanes.length > 0) {
                html += buildAnalysisCard('Cycle Lanes', selectedFeatures.lanes, '#ff9800', {
                    lengthField: 'LENGTH',
                    widthField: 'WIDTH',
                    typeField: 'ASSET_SUB_TYPE',
                    surfaceField: 'SURFACE_TYPE',
                    suburbField: 'SUBURB'
                });
            }
            
            // Custom layers analysis
            for (const [layerId, features] of Object.entries(selectedFeatures.custom)) {
                if (features.length > 0) {
                    const info = customLayers[layerId];
                    html += buildAnalysisCard(info.name, features, info.color, {
                        detectFields: true
                    });
                }
            }
            
            html += '</div>';
            
            // Actions
            html += `<div class="analysis-actions">
                <button class="primary" onclick="exportSelectedToCSV()">üì• Export to CSV</button>
                <button onclick="zoomToSelection()">üîç Zoom to Selection</button>
                <button onclick="copyAnalysisToClipboard()">üìã Copy Summary</button>
            </div>`;
            
            content.innerHTML = html;
            panel.classList.add('visible');
        }
        
        function buildAnalysisCard(title, features, color, config) {
            let html = `<div class="analysis-card">
                <h4><span class="color-dot" style="background: ${color};"></span>${title}</h4>
                <div class="metric">
                    <span>Features:</span>
                    <span class="metric-value">${features.length}</span>
                </div>`;
            
            // Calculate length if available
            const lengthField = config.lengthField || detectField(features, ['LENGTH', 'PATH_LENGTH', 'Shape__Length']);
            if (lengthField) {
                const totalLength = features.reduce((sum, f) => sum + (f.properties[lengthField] || 0), 0);
                html += `<div class="metric">
                    <span>Total Length:</span>
                    <span class="metric-value">${(totalLength / 1000).toFixed(2)} km</span>
                </div>`;
            }
            
            // Calculate average width if available
            const widthField = config.widthField || detectField(features, ['WIDTH', 'AVERAGE_WIDTH']);
            if (widthField) {
                const widths = features.map(f => f.properties[widthField]).filter(w => typeof w === 'number');
                if (widths.length > 0) {
                    const avgWidth = widths.reduce((a, b) => a + b, 0) / widths.length;
                    html += `<div class="metric">
                        <span>Avg Width:</span>
                        <span class="metric-value">${avgWidth.toFixed(1)} m</span>
                    </div>`;
                }
            }
            
            // Type breakdown
            const typeField = config.typeField || detectField(features, ['ASSET_SUB_TYPE', 'ASSET_TYPE', 'TYPE', 'type']);
            if (typeField) {
                const typeCounts = {};
                features.forEach(f => {
                    const type = f.properties[typeField] || 'Unknown';
                    typeCounts[type] = (typeCounts[type] || 0) + 1;
                });
                
                html += `<div class="breakdown">
                    <div class="breakdown-title">By Type:</div>`;
                for (const [type, count] of Object.entries(typeCounts).sort((a, b) => b[1] - a[1]).slice(0, 5)) {
                    const pct = ((count / features.length) * 100).toFixed(0);
                    html += `<div class="breakdown-item">
                        <span>${type}</span>
                        <span>${count} (${pct}%)</span>
                    </div>`;
                }
                html += '</div>';
            }
            
            // Surface breakdown
            const surfaceField = config.surfaceField || detectField(features, ['PATH_SURFACE', 'SURFACE_TYPE', 'SURFACE']);
            if (surfaceField && surfaceField !== typeField) {
                const surfaceCounts = {};
                features.forEach(f => {
                    const surface = f.properties[surfaceField] || 'Unknown';
                    surfaceCounts[surface] = (surfaceCounts[surface] || 0) + 1;
                });
                
                if (Object.keys(surfaceCounts).length > 1) {
                    html += `<div class="breakdown">
                        <div class="breakdown-title">By Surface:</div>`;
                    for (const [surface, count] of Object.entries(surfaceCounts).sort((a, b) => b[1] - a[1]).slice(0, 4)) {
                        const pct = ((count / features.length) * 100).toFixed(0);
                        html += `<div class="breakdown-item">
                            <span>${surface}</span>
                            <span>${count} (${pct}%)</span>
                        </div>`;
                    }
                    html += '</div>';
                }
            }
            
            // Suburb breakdown
            const suburbField = config.suburbField || detectField(features, ['SUBURB', 'suburb', 'LOCALITY']);
            if (suburbField) {
                const suburbCounts = {};
                features.forEach(f => {
                    const suburb = f.properties[suburbField] || 'Unknown';
                    suburbCounts[suburb] = (suburbCounts[suburb] || 0) + 1;
                });
                
                if (Object.keys(suburbCounts).length > 1) {
                    html += `<div class="breakdown">
                        <div class="breakdown-title">By Suburb:</div>`;
                    for (const [suburb, count] of Object.entries(suburbCounts).sort((a, b) => b[1] - a[1]).slice(0, 4)) {
                        const pct = ((count / features.length) * 100).toFixed(0);
                        html += `<div class="breakdown-item">
                            <span>${suburb}</span>
                            <span>${count} (${pct}%)</span>
                        </div>`;
                    }
                    html += '</div>';
                }
            }
            
            html += '</div>';
            return html;
        }
        
        function detectField(features, candidates) {
            if (!features || features.length === 0) return null;
            const props = features[0].properties;
            for (const field of candidates) {
                if (props.hasOwnProperty(field)) return field;
            }
            return null;
        }
        
        function zoomToSelection() {
            if (selectionBounds) {
                map.fitBounds(selectionBounds, { padding: [50, 50] });
            }
        }
        
        function exportSelectedToCSV() {
            let allFeatures = [];
            
            // Add paths
            selectedFeatures.paths.forEach(f => {
                allFeatures.push({ layer: 'Community Paths', ...f.properties });
            });
            
            // Add lanes
            selectedFeatures.lanes.forEach(f => {
                allFeatures.push({ layer: 'Cycle Lanes', ...f.properties });
            });
            
            // Add custom layers
            for (const [layerId, features] of Object.entries(selectedFeatures.custom)) {
                const layerName = customLayers[layerId]?.name || layerId;
                features.forEach(f => {
                    allFeatures.push({ layer: layerName, ...f.properties });
                });
            }
            
            if (allFeatures.length === 0) {
                alert('No features selected to export');
                return;
            }
            
            // Get all unique columns
            const columns = new Set(['layer']);
            allFeatures.forEach(f => Object.keys(f).forEach(k => columns.add(k)));
            const columnArray = Array.from(columns);
            
            // Build CSV
            let csv = columnArray.join(',') + '\n';
            allFeatures.forEach(f => {
                const row = columnArray.map(col => {
                    const val = f[col] ?? '';
                    // Escape quotes and wrap in quotes if contains comma
                    const strVal = String(val).replace(/"/g, '""');
                    return strVal.includes(',') ? `"${strVal}"` : strVal;
                });
                csv += row.join(',') + '\n';
            });
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'selected_features.csv';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function copyAnalysisToClipboard() {
            let text = 'SELECTION ANALYSIS\n';
            text += '==================\n\n';
            
            if (selectedFeatures.paths.length > 0) {
                text += `Community Paths: ${selectedFeatures.paths.length} features\n`;
                const totalLength = selectedFeatures.paths.reduce((sum, f) => sum + (f.properties.PATH_LENGTH || 0), 0);
                text += `  Total Length: ${(totalLength / 1000).toFixed(2)} km\n\n`;
            }
            
            if (selectedFeatures.lanes.length > 0) {
                text += `Cycle Lanes: ${selectedFeatures.lanes.length} features\n`;
                const totalLength = selectedFeatures.lanes.reduce((sum, f) => sum + (f.properties.LENGTH || 0), 0);
                text += `  Total Length: ${(totalLength / 1000).toFixed(2)} km\n\n`;
            }
            
            for (const [layerId, features] of Object.entries(selectedFeatures.custom)) {
                if (features.length > 0) {
                    const name = customLayers[layerId]?.name || layerId;
                    text += `${name}: ${features.length} features\n\n`;
                }
            }
            
            navigator.clipboard.writeText(text).then(() => {
                alert('Analysis copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy to clipboard');
            });
        }
        
        // ==================== END SELECTION TOOL ====================
        
        // ==================== FEEDBACK SYSTEM ====================
        
        // Feedback state
        let feedbackState = {
            marker: null,
            latlng: null,
            pathInfo: null,
            rating: null
        };
        
        // Feedback layer storage
        let feedbackLayer = null;
        let feedbackData = { type: 'FeatureCollection', features: [] };
        
        function closeFeedbackPanel() {
            document.getElementById('feedbackPanel').classList.remove('visible');
            if (selectionMode === 'feedback') {
                setMode('pan');
            }
            resetFeedbackForm();
        }
        
        function resetFeedbackForm() {
            // Clear marker
            if (feedbackState.marker) {
                map.removeLayer(feedbackState.marker);
                feedbackState.marker = null;
            }
            
            // Reset state
            feedbackState.latlng = null;
            feedbackState.pathInfo = null;
            feedbackState.rating = null;
            
            // Reset form UI
            document.getElementById('feedbackLocation').style.display = 'none';
            document.getElementById('feedbackForm').style.display = 'none';
            document.getElementById('feedbackCategory').value = '';
            document.getElementById('feedbackComment').value = '';
            document.getElementById('feedbackName').value = '';
            document.getElementById('feedbackEmail').value = '';
            document.querySelectorAll('.feedback-rating button').forEach(btn => btn.classList.remove('selected'));
            document.getElementById('sendFeedbackBtn').disabled = true;
            
            // Update instructions
            document.querySelector('.feedback-instructions').textContent = 'Click on any path to select a location for your feedback.';
        }
        
        function handleFeedbackClick(e, feature, layer) {
            if (selectionMode !== 'feedback') return;
            
            // Remove previous marker
            if (feedbackState.marker) {
                map.removeLayer(feedbackState.marker);
            }
            
            // Store location and path info
            feedbackState.latlng = e.latlng;
            feedbackState.pathInfo = {
                name: feature.properties.ASSET_NAME || feature.properties.LOCATION || 'Unknown path',
                type: feature.properties.ASSET_SUB_TYPE || feature.properties.ASSET_TYPE || 'Path',
                surface: feature.properties.PATH_SURFACE || feature.properties.SURFACE_TYPE || 'Unknown',
                suburb: feature.properties.SUBURB || 'Unknown'
            };
            
            // Add marker at click location
            feedbackState.marker = L.circleMarker(e.latlng, {
                radius: 10,
                fillColor: '#2196F3',
                color: '#fff',
                weight: 3,
                fillOpacity: 1
            }).addTo(map);
            
            // Update UI
            document.getElementById('feedbackLocation').style.display = 'block';
            document.getElementById('feedbackLocationText').textContent = 
                `${feedbackState.pathInfo.name} (${feedbackState.pathInfo.suburb})`;
            document.getElementById('feedbackForm').style.display = 'block';
            document.querySelector('.feedback-instructions').textContent = 'Rate this location and provide your feedback.';
            
            updateSelectionStatus('Location selected - fill in feedback form');
        }
        
        function setFeedbackRating(rating) {
            feedbackState.rating = rating;
            
            // Update button styles
            document.querySelectorAll('.feedback-rating button').forEach(btn => btn.classList.remove('selected'));
            if (rating === 'good') {
                document.querySelector('.feedback-rating .thumbs-up').classList.add('selected');
            } else {
                document.querySelector('.feedback-rating .thumbs-down').classList.add('selected');
            }
            
            validateFeedbackForm();
        }
        
        function validateFeedbackForm() {
            const rating = feedbackState.rating;
            const category = document.getElementById('feedbackCategory').value;
            
            const isValid = rating && category && feedbackState.latlng;
            document.getElementById('sendFeedbackBtn').disabled = !isValid;
        }
        
        // Add validation listener to category select
        document.getElementById('feedbackCategory')?.addEventListener('change', validateFeedbackForm);
        
        function downloadFeedback() {
            if (!feedbackState.latlng || !feedbackState.rating) {
                alert('Please select a location and rating');
                return;
            }
            
            const category = document.getElementById('feedbackCategory').value;
            if (!category) {
                alert('Please select a reason for your rating');
                return;
            }
            
            const comment = document.getElementById('feedbackComment').value;
            const name = document.getElementById('feedbackName').value;
            const email = document.getElementById('feedbackEmail').value;
            
            // Create GeoJSON feature for the feedback
            const feedbackFeature = {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [feedbackState.latlng.lng, feedbackState.latlng.lat]
                },
                properties: {
                    rating: feedbackState.rating,
                    category: category,
                    categoryLabel: getCategoryLabel(category),
                    comment: comment,
                    submitterName: name,
                    submitterEmail: email,
                    pathName: feedbackState.pathInfo.name,
                    pathType: feedbackState.pathInfo.type,
                    pathSurface: feedbackState.pathInfo.surface,
                    suburb: feedbackState.pathInfo.suburb,
                    timestamp: new Date().toISOString()
                }
            };
            
            // Create GeoJSON file content
            const geojsonContent = JSON.stringify({
                type: 'FeatureCollection',
                features: [feedbackFeature]
            }, null, 2);
            
            // Create a blob and download
            const blob = new Blob([geojsonContent], { type: 'application/json' });
            const downloadUrl = URL.createObjectURL(blob);
            
            // Download the GeoJSON file
            const downloadLink = document.createElement('a');
            downloadLink.href = downloadUrl;
            downloadLink.download = `feedback_${feedbackState.rating}_${Date.now()}.geojson`;
            downloadLink.click();
            
            // Clean up
            URL.revokeObjectURL(downloadUrl);
            
            // Reset form
            resetFeedbackForm();
        }
        
        function getCategoryLabel(category) {
            const labels = {
                'surface': 'Surface Quality',
                'safety': 'Safety Concern',
                'lighting': 'Lighting',
                'other': 'Other'
            };
            return labels[category] || category;
        }
        
        // Load feedback files
        function loadFeedbackFiles(input) {
            const files = input.files;
            if (!files.length) return;
            
            let loadedCount = 0;
            let totalFeatures = 0;
            
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const geojson = JSON.parse(e.target.result);
                        
                        if (geojson.features) {
                            geojson.features.forEach(feature => {
                                // Validate it's a feedback feature
                                if (feature.properties && feature.properties.rating) {
                                    feedbackData.features.push(feature);
                                    totalFeatures++;
                                }
                            });
                        }
                        
                        loadedCount++;
                        
                        // When all files loaded, update the layer
                        if (loadedCount === files.length) {
                            updateFeedbackLayer();
                            document.getElementById('feedbackLayerInfo').style.display = 'block';
                            document.getElementById('feedbackLayerInfo').innerHTML = 
                                `‚úì Loaded ${totalFeatures} feedback point(s) from ${loadedCount} file(s)`;
                            updateFilterPanel();
                        }
                    } catch (err) {
                        alert('Error parsing feedback file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            });
        }
        
        function updateFeedbackLayer() {
            // Remove existing layer
            if (feedbackLayer) {
                map.removeLayer(feedbackLayer);
            }
            
            if (feedbackData.features.length === 0) return;
            
            // Apply filters if any
            const filteredFeatures = applyFeedbackFilters(feedbackData.features);
            
            // Create the feedback layer with custom icons
            feedbackLayer = L.geoJSON({ type: 'FeatureCollection', features: filteredFeatures }, {
                pointToLayer: function(feature, latlng) {
                    const isGood = feature.properties.rating === 'good';
                    return L.marker(latlng, {
                        icon: L.divIcon({
                            className: 'feedback-marker',
                            html: `<div style="
                                font-size: 24px;
                                text-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                cursor: pointer;
                            ">${isGood ? 'üëç' : 'üëé'}</div>`,
                            iconSize: [30, 30],
                            iconAnchor: [15, 15]
                        })
                    });
                },
                onEachFeature: function(feature, layer) {
                    const props = feature.properties;
                    const ratingEmoji = props.rating === 'good' ? 'üëç' : 'üëé';
                    const ratingColor = props.rating === 'good' ? '#4CAF50' : '#f44336';
                    
                    let popupContent = `
                        <div class="feedback-popup">
                            <div class="rating" style="color: ${ratingColor};">${ratingEmoji} ${props.rating === 'good' ? 'Good' : 'Bad'}</div>
                            <div class="category">${props.categoryLabel || props.category}</div>
                            ${props.comment ? `<div class="comment">${props.comment}</div>` : ''}
                            <div class="meta">
                                <strong>Path:</strong> ${props.pathName || 'Unknown'}<br>
                                <strong>Suburb:</strong> ${props.suburb || 'Unknown'}<br>
                                ${props.submitterName ? `<strong>By:</strong> ${props.submitterName}<br>` : ''}
                                <strong>Date:</strong> ${props.timestamp ? new Date(props.timestamp).toLocaleDateString() : 'Unknown'}
                            </div>
                        </div>
                    `;
                    
                    layer.bindPopup(popupContent, { maxWidth: 300 });
                }
            }).addTo(map);
            
            // Update the layer visibility section
            updateFeedbackLayerUI();
            updateFilterPanel();
        }
        
        function applyFeedbackFilters(features) {
            if (!feedbackFilters.rating.length && !feedbackFilters.category.length) {
                return features;
            }
            
            return features.filter(f => {
                const props = f.properties;
                
                // Check rating filter
                if (feedbackFilters.rating.length > 0 && !feedbackFilters.rating.includes(props.rating)) {
                    return false;
                }
                
                // Check category filter
                if (feedbackFilters.category.length > 0 && !feedbackFilters.category.includes(props.category)) {
                    return false;
                }
                
                return true;
            });
        }
        
        function updateFeedbackLayerUI() {
            const container = document.getElementById('feedbackLayerControls');
            if (!container) return;
            
            if (feedbackData.features.length > 0) {
                const filteredCount = applyFeedbackFilters(feedbackData.features).length;
                container.innerHTML = `
                    <div class="layer-toggle">
                        <input type="checkbox" id="toggleFeedback" checked onchange="toggleFeedbackLayer()">
                        <label for="toggleFeedback">Feedback (${filteredCount}/${feedbackData.features.length})</label>
                    </div>
                `;
                container.style.display = 'block';
            } else {
                container.style.display = 'none';
            }
        }
        
        function toggleFeedbackLayer() {
            const checkbox = document.getElementById('toggleFeedback');
            if (checkbox.checked) {
                if (feedbackLayer) feedbackLayer.addTo(map);
            } else {
                if (feedbackLayer) map.removeLayer(feedbackLayer);
            }
        }
        
        // Feedback filters
        let feedbackFilters = {
            rating: [],    // ['good', 'bad'] or empty for all
            category: []   // ['surface', 'safety', 'lighting', 'other'] or empty for all
        };
        
        function updateFeedbackFilter(filterType, value, isChecked) {
            if (isChecked) {
                if (!feedbackFilters[filterType].includes(value)) {
                    feedbackFilters[filterType].push(value);
                }
            } else {
                const idx = feedbackFilters[filterType].indexOf(value);
                if (idx > -1) {
                    feedbackFilters[filterType].splice(idx, 1);
                }
            }
            
            updateFeedbackLayer();
        }
        
        function clearFeedbackFilters() {
            feedbackFilters = { rating: [], category: [] };
            updateFeedbackLayer();
            updateFilterPanel();
        }
        
        // Attach feedback click handlers to layers
        function attachFeedbackClickHandler(layer, feature) {
            layer.on('click', function(e) {
                if (selectionMode === 'feedback') {
                    L.DomEvent.stopPropagation(e);
                    handleFeedbackClick(e, feature, layer);
                }
            });
        }
        
        // Map-level click handler for feedback with increased sensitivity
        map.on('click', function(e) {
            if (selectionMode !== 'feedback') return;
            
            // Find the nearest path feature within tolerance
            const clickPoint = e.latlng;
            const tolerance = 50; // meters - increased sensitivity
            
            let nearestFeature = null;
            let nearestDistance = tolerance;
            let nearestPoint = null;
            
            // Check paths layer
            if (coreLayers.paths.filteredData && coreLayers.paths.filteredData.features) {
                for (const feature of coreLayers.paths.filteredData.features) {
                    const result = findNearestPointOnFeature(clickPoint, feature);
                    if (result && result.distance < nearestDistance) {
                        nearestDistance = result.distance;
                        nearestFeature = feature;
                        nearestPoint = result.point;
                    }
                }
            }
            
            // Check lanes layer
            if (coreLayers.lanes.filteredData && coreLayers.lanes.filteredData.features) {
                for (const feature of coreLayers.lanes.filteredData.features) {
                    const result = findNearestPointOnFeature(clickPoint, feature);
                    if (result && result.distance < nearestDistance) {
                        nearestDistance = result.distance;
                        nearestFeature = feature;
                        nearestPoint = result.point;
                    }
                }
            }
            
            // Check custom line layers
            for (const [layerId, info] of Object.entries(customLayers)) {
                if (info.geometryType === 'line' && info.filteredData && info.filteredData.features) {
                    for (const feature of info.filteredData.features) {
                        const result = findNearestPointOnFeature(clickPoint, feature);
                        if (result && result.distance < nearestDistance) {
                            nearestDistance = result.distance;
                            nearestFeature = feature;
                            nearestPoint = result.point;
                        }
                    }
                }
            }
            
            if (nearestFeature) {
                // Create a synthetic event with the snapped point
                const syntheticEvent = {
                    latlng: nearestPoint || clickPoint,
                    originalEvent: e.originalEvent
                };
                handleFeedbackClick(syntheticEvent, nearestFeature, null);
            }
        });
        
        function findNearestPointOnFeature(clickPoint, feature) {
            const geom = feature.geometry;
            if (!geom) return null;
            
            let coords = [];
            if (geom.type === 'LineString') {
                coords = geom.coordinates.map(c => L.latLng(c[1], c[0]));
            } else if (geom.type === 'MultiLineString') {
                coords = geom.coordinates.flat().map(c => L.latLng(c[1], c[0]));
            } else {
                return null;
            }
            
            if (coords.length < 2) return null;
            
            let minDist = Infinity;
            let nearestPoint = coords[0];
            
            // Check distance to each vertex
            for (const coord of coords) {
                const dist = clickPoint.distanceTo(coord);
                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = coord;
                }
            }
            
            // Check distance to line segments (interpolated points)
            for (let i = 0; i < coords.length - 1; i++) {
                const segResult = nearestPointOnSegment(clickPoint, coords[i], coords[i + 1]);
                const dist = clickPoint.distanceTo(segResult.point);
                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = segResult.point;
                }
            }
            
            return { distance: minDist, point: nearestPoint };
        }
        
        function nearestPointOnSegment(point, segStart, segEnd) {
            const dx = segEnd.lng - segStart.lng;
            const dy = segEnd.lat - segStart.lat;
            
            if (dx === 0 && dy === 0) {
                return { point: segStart, t: 0 };
            }
            
            const t = Math.max(0, Math.min(1,
                ((point.lng - segStart.lng) * dx + (point.lat - segStart.lat) * dy) /
                (dx * dx + dy * dy)
            ));
            
            const nearestLat = segStart.lat + t * dy;
            const nearestLng = segStart.lng + t * dx;
            
            return { point: L.latLng(nearestLat, nearestLng), t: t };
        }
        
        // ==================== END FEEDBACK SYSTEM ====================
        
        function applyPreset(presetName) {
            const preset = presets[presetName];
            document.getElementById('layerName').value = preset.name;
            document.getElementById('layerColor').value = preset.color;
            document.getElementById('layerType').value = preset.type;
        }
        
        function getPathColor(subType) {
            return pathColors[subType] || pathColors['DEFAULT'];
        }
        
        function getLaneColor(subType) {
            return laneColors[subType] || laneColors['DEFAULT'];
        }
        
        function formatPopupContent(properties, layerName) {
            let html = '<div class="popup-content">';
            
            const titleFields = ['ASSET_NAME', 'NAME', 'name', 'DESCRIPTION', 'description', 'ID', 'id', 'OBJECTID'];
            let title = layerName;
            for (const field of titleFields) {
                if (properties[field]) {
                    title = properties[field];
                    break;
                }
            }
            
            html += `<strong>${title}</strong>`;
            
            const skipFields = ['Shape__Length', 'Shape__Area', 'GlobalID', 'OBJECTID'];
            for (const [key, value] of Object.entries(properties)) {
                if (value !== null && value !== '' && !skipFields.includes(key)) {
                    let displayValue = value;
                    if (typeof value === 'number') {
                        displayValue = Number.isInteger(value) ? value : value.toFixed(2);
                    }
                    html += `<div class="property"><span class="property-label">${key}:</span> ${displayValue}</div>`;
                }
            }
            
            html += '</div>';
            return html;
        }
        
        function detectGeometryType(geojson) {
            if (!geojson.features || geojson.features.length === 0) return 'point';
            
            const firstGeom = geojson.features[0].geometry;
            if (!firstGeom) return 'point';
            
            switch (firstGeom.type) {
                case 'Point':
                case 'MultiPoint':
                    return 'point';
                case 'LineString':
                case 'MultiLineString':
                    return 'line';
                case 'Polygon':
                case 'MultiPolygon':
                    return 'polygon';
                default:
                    return 'point';
            }
        }
        
        function getUniqueValues(features, field) {
            const values = new Set();
            features.forEach(f => {
                if (f.properties[field] !== null && f.properties[field] !== undefined && f.properties[field] !== '') {
                    values.add(f.properties[field]);
                }
            });
            return Array.from(values).sort();
        }
        
        function getNumericRange(features, field) {
            let min = Infinity, max = -Infinity;
            features.forEach(f => {
                const val = f.properties[field];
                if (typeof val === 'number' && !isNaN(val)) {
                    min = Math.min(min, val);
                    max = Math.max(max, val);
                }
            });
            return { min: min === Infinity ? 0 : min, max: max === -Infinity ? 0 : max };
        }
        
        function getAvailableFilterFields(features) {
            if (!features || features.length === 0) return { categorical: [], numeric: [] };
            
            const sampleProps = features[0].properties;
            const categorical = [];
            const numeric = [];
            
            for (const field of Object.keys(sampleProps)) {
                if (filterableFields.includes(field)) {
                    const uniqueVals = getUniqueValues(features, field);
                    if (uniqueVals.length > 0 && uniqueVals.length <= 50) {
                        categorical.push({ field, values: uniqueVals });
                    }
                }
                if (numericFields.includes(field)) {
                    const range = getNumericRange(features, field);
                    if (range.max > range.min) {
                        numeric.push({ field, ...range });
                    }
                }
            }
            
            return { categorical, numeric };
        }
        
        function applyFilters(data, filters) {
            if (!data || !data.features) return data;
            if (Object.keys(filters).length === 0) return data;
            
            const filteredFeatures = data.features.filter(feature => {
                for (const [field, filterConfig] of Object.entries(filters)) {
                    const value = feature.properties[field];
                    
                    if (filterConfig.type === 'categorical') {
                        if (filterConfig.values.length > 0 && !filterConfig.values.includes(value)) {
                            return false;
                        }
                    } else if (filterConfig.type === 'numeric') {
                        if (typeof value === 'number') {
                            if (filterConfig.min !== undefined && value < filterConfig.min) return false;
                            if (filterConfig.max !== undefined && value > filterConfig.max) return false;
                        }
                    }
                }
                return true;
            });
            
            return { ...data, features: filteredFeatures };
        }
        
        function updateFilterPanel() {
            const container = document.getElementById('filterContent');
            let html = '';
            
            // Core layers filters
            if (coreLayers.paths.data) {
                html += buildFilterSection('paths', 'Community Paths', coreLayers.paths.data.features, coreLayers.paths.filters);
            }
            
            if (coreLayers.lanes.data) {
                html += buildFilterSection('lanes', 'Cycle Lanes', coreLayers.lanes.data.features, coreLayers.lanes.filters);
            }
            
            // Feedback layer filters
            if (feedbackData.features.length > 0) {
                html += buildFeedbackFilterSection();
            }
            
            // Custom layers filters (excluding feedback which is handled separately)
            for (const [layerId, info] of Object.entries(customLayers)) {
                if (layerId === 'feedback') continue; // Skip feedback, handled above
                if (info.data && info.data.features) {
                    html += buildFilterSection(layerId, info.name, info.data.features, info.filters || {});
                }
            }
            
            if (!html) {
                html = '<p class="no-data-msg">Load datasets to enable filtering</p>';
            }
            
            container.innerHTML = html;
        }
        
        function buildFeedbackFilterSection() {
            const filteredCount = applyFeedbackFilters(feedbackData.features).length;
            const totalCount = feedbackData.features.length;
            
            // Get unique ratings and categories
            const ratings = [...new Set(feedbackData.features.map(f => f.properties.rating))];
            const categories = [...new Set(feedbackData.features.map(f => f.properties.category))];
            
            let html = `<div class="filter-section">
                <h4>
                    Feedback
                    <button class="btn btn-sm btn-secondary" onclick="clearFeedbackFilters()">Clear</button>
                </h4>
                <div class="filter-count">Showing ${filteredCount} of ${totalCount} feedback points</div>`;
            
            // Rating filter
            html += `
                <div class="filter-group">
                    <label>Rating</label>
                    <div class="select-all-row">
                        <button onclick="selectAllFeedbackFilter('rating')">All</button>
                        <button onclick="selectNoneFeedbackFilter('rating')">None</button>
                    </div>
                    <div class="checkbox-group">`;
            
            const ratingLabels = { 'good': 'üëç Good', 'bad': 'üëé Bad' };
            for (const rating of ['good', 'bad']) {
                if (!ratings.includes(rating)) continue;
                const checked = feedbackFilters.rating.length === 0 || feedbackFilters.rating.includes(rating) ? 'checked' : '';
                html += `
                    <div class="checkbox-item">
                        <input type="checkbox" id="fb-rating-${rating}" ${checked}
                            onchange="toggleFeedbackFilterValue('rating', '${rating}', this.checked)">
                        <label for="fb-rating-${rating}">${ratingLabels[rating]}</label>
                    </div>`;
            }
            html += `</div></div>`;
            
            // Category filter
            html += `
                <div class="filter-group">
                    <label>Category</label>
                    <div class="select-all-row">
                        <button onclick="selectAllFeedbackFilter('category')">All</button>
                        <button onclick="selectNoneFeedbackFilter('category')">None</button>
                    </div>
                    <div class="checkbox-group">`;
            
            const categoryLabels = { 
                'surface': 'Surface Quality', 
                'safety': 'Safety Concern', 
                'lighting': 'Lighting', 
                'other': 'Other' 
            };
            for (const cat of ['surface', 'safety', 'lighting', 'other']) {
                if (!categories.includes(cat)) continue;
                const checked = feedbackFilters.category.length === 0 || feedbackFilters.category.includes(cat) ? 'checked' : '';
                html += `
                    <div class="checkbox-item">
                        <input type="checkbox" id="fb-cat-${cat}" ${checked}
                            onchange="toggleFeedbackFilterValue('category', '${cat}', this.checked)">
                        <label for="fb-cat-${cat}">${categoryLabels[cat] || cat}</label>
                    </div>`;
            }
            html += `</div></div>`;
            
            html += '</div>';
            return html;
        }
        
        function toggleFeedbackFilterValue(filterType, value, isChecked) {
            // Get all values for this filter type
            const allValues = filterType === 'rating' ? ['good', 'bad'] : ['surface', 'safety', 'lighting', 'other'];
            
            // If filters are empty (showing all), initialize with all values first
            if (feedbackFilters[filterType].length === 0) {
                feedbackFilters[filterType] = [...allValues];
            }
            
            if (isChecked) {
                if (!feedbackFilters[filterType].includes(value)) {
                    feedbackFilters[filterType].push(value);
                }
            } else {
                const idx = feedbackFilters[filterType].indexOf(value);
                if (idx > -1) {
                    feedbackFilters[filterType].splice(idx, 1);
                }
            }
            
            // If all values selected, clear the filter (show all)
            if (feedbackFilters[filterType].length === allValues.length) {
                feedbackFilters[filterType] = [];
            }
            
            updateFeedbackLayer();
        }
        
        function selectAllFeedbackFilter(filterType) {
            feedbackFilters[filterType] = [];
            updateFeedbackLayer();
            updateFilterPanel();
        }
        
        function selectNoneFeedbackFilter(filterType) {
            feedbackFilters[filterType] = ['__none__']; // Special value that matches nothing
            updateFeedbackLayer();
            updateFilterPanel();
        }
        
        function buildFilterSection(layerId, layerName, features, currentFilters) {
            const { categorical, numeric } = getAvailableFilterFields(features);
            
            if (categorical.length === 0 && numeric.length === 0) {
                return '';
            }
            
            const filteredCount = applyFilters({ features }, currentFilters).features.length;
            const totalCount = features.length;
            
            let html = `<div class="filter-section">
                <h4>
                    ${layerName}
                    <button class="btn btn-sm btn-secondary" onclick="clearFilters('${layerId}')">Clear</button>
                </h4>
                <div class="filter-count">Showing ${filteredCount} of ${totalCount} features</div>`;
            
            // Categorical filters (checkboxes)
            for (const { field, values } of categorical) {
                const selectedValues = currentFilters[field]?.values || values;
                const colorConfig = filterColors[layerId] || { enabled: false, field: null, colors: {} };
                const isColorField = colorConfig.enabled && colorConfig.field === field;
                
                // Initialize colors for this field if not exists
                if (!filterColors[layerId]) {
                    filterColors[layerId] = { enabled: false, field: null, colors: {} };
                }
                if (!filterColors[layerId].colors[field]) {
                    filterColors[layerId].colors[field] = {};
                    values.forEach((val, idx) => {
                        filterColors[layerId].colors[field][val] = colorPalette[idx % colorPalette.length];
                    });
                }
                
                html += `
                    <div class="filter-group">
                        <label>${formatFieldName(field)}</label>
                        <div class="filter-color-mode">
                            <input type="checkbox" id="color-by-${layerId}-${field}" 
                                ${isColorField ? 'checked' : ''}
                                onchange="setColorByField('${layerId}', '${field}', this.checked)">
                            <label for="color-by-${layerId}-${field}">Color by this field</label>
                        </div>
                        <div class="select-all-row">
                            <button onclick="selectAllValues('${layerId}', '${field}')">All</button>
                            <button onclick="selectNoneValues('${layerId}', '${field}')">None</button>
                        </div>
                        <div class="checkbox-group" id="filter-${layerId}-${field}">`;
                
                for (const val of values) {
                    const checked = selectedValues.includes(val) ? 'checked' : '';
                    const escapedVal = String(val).replace(/'/g, "\\'");
                    const currentColor = filterColors[layerId].colors[field][val] || colorPalette[0];
                    html += `
                        <div class="checkbox-item">
                            <input type="checkbox" id="cb-${layerId}-${field}-${val}" ${checked}
                                onchange="updateCategoricalFilter('${layerId}', '${field}', '${escapedVal}', this.checked)">
                            <label for="cb-${layerId}-${field}-${val}">${val}</label>
                            <input type="color" value="${currentColor}" 
                                onchange="setFilterValueColor('${layerId}', '${field}', '${escapedVal}', this.value)"
                                title="Set color for ${val}">
                        </div>`;
                }
                
                html += `</div></div>`;
            }
            
            // Numeric filters (range inputs)
            for (const { field, min, max } of numeric) {
                const currentMin = currentFilters[field]?.min ?? min;
                const currentMax = currentFilters[field]?.max ?? max;
                html += `
                    <div class="filter-group">
                        <label>${formatFieldName(field)} (${min.toFixed(1)} - ${max.toFixed(1)})</label>
                        <div class="filter-row">
                            <input type="number" placeholder="Min" value="${currentMin}" step="0.1"
                                onchange="updateNumericFilter('${layerId}', '${field}', 'min', this.value)">
                            <span>to</span>
                            <input type="number" placeholder="Max" value="${currentMax}" step="0.1"
                                onchange="updateNumericFilter('${layerId}', '${field}', 'max', this.value)">
                        </div>
                    </div>`;
            }
            
            html += '</div>';
            return html;
        }
        
        function formatFieldName(field) {
            return field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
        
        function setColorByField(layerId, field, enabled) {
            if (!filterColors[layerId]) {
                filterColors[layerId] = { enabled: false, field: null, colors: {} };
            }
            
            if (enabled) {
                filterColors[layerId].enabled = true;
                filterColors[layerId].field = field;
            } else {
                filterColors[layerId].enabled = false;
                filterColors[layerId].field = null;
            }
            
            // Uncheck other "color by" checkboxes for this layer
            document.querySelectorAll(`input[id^="color-by-${layerId}-"]`).forEach(cb => {
                if (cb.id !== `color-by-${layerId}-${field}`) {
                    cb.checked = false;
                }
            });
            
            // Re-apply layer styles
            applyLayerFilters(layerId);
        }
        
        function setFilterValueColor(layerId, field, value, color) {
            if (!filterColors[layerId]) {
                filterColors[layerId] = { enabled: false, field: null, colors: {} };
            }
            if (!filterColors[layerId].colors[field]) {
                filterColors[layerId].colors[field] = {};
            }
            
            filterColors[layerId].colors[field][value] = color;
            
            // If coloring is enabled for this field, re-apply
            if (filterColors[layerId].enabled && filterColors[layerId].field === field) {
                applyLayerFilters(layerId);
            }
        }
        
        function getFeatureColorByFilter(layerId, feature) {
            const colorConfig = filterColors[layerId];
            if (!colorConfig || !colorConfig.enabled || !colorConfig.field) {
                return null;
            }
            
            const fieldValue = feature.properties[colorConfig.field];
            if (fieldValue && colorConfig.colors[colorConfig.field]) {
                return colorConfig.colors[colorConfig.field][fieldValue] || null;
            }
            return null;
        }
        
        function updateCategoricalFilter(layerId, field, value, isChecked) {
            let layerInfo;
            if (layerId === 'paths' || layerId === 'lanes') {
                layerInfo = coreLayers[layerId];
            } else {
                layerInfo = customLayers[layerId];
            }
            
            if (!layerInfo) return;
            
            if (!layerInfo.filters) layerInfo.filters = {};
            if (!layerInfo.filters[field]) {
                const allValues = getUniqueValues(layerInfo.data.features, field);
                layerInfo.filters[field] = { type: 'categorical', values: [...allValues] };
            }
            
            const filterValues = layerInfo.filters[field].values;
            if (isChecked && !filterValues.includes(value)) {
                filterValues.push(value);
            } else if (!isChecked) {
                const idx = filterValues.indexOf(value);
                if (idx > -1) filterValues.splice(idx, 1);
            }
            
            applyLayerFilters(layerId);
        }
        
        function updateNumericFilter(layerId, field, bound, value) {
            let layerInfo;
            if (layerId === 'paths' || layerId === 'lanes') {
                layerInfo = coreLayers[layerId];
            } else {
                layerInfo = customLayers[layerId];
            }
            
            if (!layerInfo) return;
            
            if (!layerInfo.filters) layerInfo.filters = {};
            if (!layerInfo.filters[field]) {
                layerInfo.filters[field] = { type: 'numeric' };
            }
            
            layerInfo.filters[field][bound] = parseFloat(value);
            applyLayerFilters(layerId);
        }
        
        function selectAllValues(layerId, field) {
            let layerInfo;
            if (layerId === 'paths' || layerId === 'lanes') {
                layerInfo = coreLayers[layerId];
            } else {
                layerInfo = customLayers[layerId];
            }
            
            if (!layerInfo || !layerInfo.data) return;
            
            const allValues = getUniqueValues(layerInfo.data.features, field);
            if (!layerInfo.filters) layerInfo.filters = {};
            layerInfo.filters[field] = { type: 'categorical', values: [...allValues] };
            
            applyLayerFilters(layerId);
            updateFilterPanel();
        }
        
        function selectNoneValues(layerId, field) {
            let layerInfo;
            if (layerId === 'paths' || layerId === 'lanes') {
                layerInfo = coreLayers[layerId];
            } else {
                layerInfo = customLayers[layerId];
            }
            
            if (!layerInfo) return;
            
            if (!layerInfo.filters) layerInfo.filters = {};
            layerInfo.filters[field] = { type: 'categorical', values: [] };
            
            applyLayerFilters(layerId);
            updateFilterPanel();
        }
        
        function clearFilters(layerId) {
            let layerInfo;
            if (layerId === 'paths' || layerId === 'lanes') {
                layerInfo = coreLayers[layerId];
            } else {
                layerInfo = customLayers[layerId];
            }
            
            if (!layerInfo) return;
            
            layerInfo.filters = {};
            applyLayerFilters(layerId);
            updateFilterPanel();
        }
        
        function applyLayerFilters(layerId) {
            if (layerId === 'paths') {
                applyPathsFilters();
            } else if (layerId === 'lanes') {
                applyLanesFilters();
            } else {
                applyCustomLayerFilters(layerId);
            }
            updateFilterPanel();
            updateStats();
        }
        
        function applyPathsFilters() {
            if (!coreLayers.paths.data) return;
            
            if (coreLayers.paths.layer) {
                map.removeLayer(coreLayers.paths.layer);
            }
            
            const filteredData = applyFilters(coreLayers.paths.data, coreLayers.paths.filters);
            coreLayers.paths.filteredData = filteredData;
            
            coreLayers.paths.layer = L.geoJSON(filteredData, {
                style: function(feature) {
                    return getLayerStyle('paths', feature);
                },
                onEachFeature: function(feature, layer) {
                    layer.bindPopup(formatPopupContent(feature.properties, 'Community Path'));
                    attachFeedbackClickHandler(layer, feature);
                }
            });
            
            if (document.getElementById('togglePaths').checked) {
                coreLayers.paths.layer.addTo(map);
            }
        }
        
        function applyLanesFilters() {
            if (!coreLayers.lanes.data) return;
            
            if (coreLayers.lanes.layer) {
                map.removeLayer(coreLayers.lanes.layer);
            }
            
            const filteredData = applyFilters(coreLayers.lanes.data, coreLayers.lanes.filters);
            coreLayers.lanes.filteredData = filteredData;
            
            coreLayers.lanes.layer = L.geoJSON(filteredData, {
                style: function(feature) {
                    return getLayerStyle('lanes', feature);
                },
                onEachFeature: function(feature, layer) {
                    layer.bindPopup(formatPopupContent(feature.properties, 'Cycle Lane'));
                    attachFeedbackClickHandler(layer, feature);
                }
            });
            
            if (document.getElementById('toggleLanes').checked) {
                coreLayers.lanes.layer.addTo(map);
            }
        }
        
        function applyCustomLayerFilters(layerId) {
            const info = customLayers[layerId];
            if (!info || !info.data) return;
            
            if (info.layer) {
                map.removeLayer(info.layer);
            }
            
            const filteredData = applyFilters(info.data, info.filters || {});
            info.filteredData = filteredData;
            
            // Initialize custom styles if not exists
            if (!customLayerStyles[layerId]) {
                customLayerStyles[layerId] = {
                    color: info.color,
                    weight: info.geometryType === 'point' ? 2 : 3,
                    opacity: 0.8,
                    fillOpacity: 0.8,
                    radius: 6,
                    dashArray: '',
                    lineCap: 'round',
                    lineJoin: 'round'
                };
            }
            
            info.layer = createLayerFromGeoJSON(filteredData, info.color, info.geometryType, info.name, layerId);
            
            if (info.visible) {
                info.layer.addTo(map);
            }
        }
        
        function createLayerFromGeoJSON(geojson, color, geometryType, layerName, layerId = null) {
            const actualType = geometryType === 'auto' ? detectGeometryType(geojson) : geometryType;
            const styles = layerId && customLayerStyles[layerId] ? customLayerStyles[layerId] : { color, weight: 3, opacity: 0.8, radius: 6, fillOpacity: 0.8 };
            
            if (actualType === 'point') {
                return L.geoJSON(geojson, {
                    pointToLayer: function(feature, latlng) {
                        return L.circleMarker(latlng, {
                            radius: styles.radius || 6,
                            fillColor: styles.color || color,
                            color: '#fff',
                            weight: styles.weight || 2,
                            opacity: styles.opacity || 1,
                            fillOpacity: styles.fillOpacity || 0.8
                        });
                    },
                    onEachFeature: function(feature, layer) {
                        layer.bindPopup(formatPopupContent(feature.properties, layerName));
                    }
                });
            } else if (actualType === 'line') {
                return L.geoJSON(geojson, {
                    style: {
                        color: styles.color || color,
                        weight: styles.weight || 3,
                        opacity: styles.opacity || 0.8,
                        dashArray: styles.dashArray || '',
                        lineCap: styles.lineCap || 'round',
                        lineJoin: styles.lineJoin || 'round'
                    },
                    onEachFeature: function(feature, layer) {
                        layer.bindPopup(formatPopupContent(feature.properties, layerName));
                        attachFeedbackClickHandler(layer, feature);
                    }
                });
            } else {
                return L.geoJSON(geojson, {
                    style: {
                        color: styles.color || color,
                        weight: styles.weight || 2,
                        opacity: styles.opacity || 0.8,
                        fillColor: styles.color || color,
                        fillOpacity: styles.fillOpacity || 0.3,
                        dashArray: styles.dashArray || ''
                    },
                    onEachFeature: function(feature, layer) {
                        layer.bindPopup(formatPopupContent(feature.properties, layerName));
                    }
                });
            }
        }
        
        function loadCoreDataset(input, type) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const geojson = JSON.parse(e.target.result);
                    
                    if (coreLayers[type].layer) {
                        map.removeLayer(coreLayers[type].layer);
                    }
                    
                    coreLayers[type].data = geojson;
                    coreLayers[type].filteredData = geojson;
                    coreLayers[type].filters = {};
                    
                    if (type === 'paths') {
                        coreLayers[type].layer = L.geoJSON(geojson, {
                            style: function(feature) {
                                return getLayerStyle('paths', feature);
                            },
                            onEachFeature: function(feature, layer) {
                                layer.bindPopup(formatPopupContent(feature.properties, 'Community Path'));
                                attachFeedbackClickHandler(layer, feature);
                            }
                        }).addTo(map);
                        document.getElementById('togglePaths').checked = true;
                    } else {
                        coreLayers[type].layer = L.geoJSON(geojson, {
                            style: function(feature) {
                                return getLayerStyle('lanes', feature);
                            },
                            onEachFeature: function(feature, layer) {
                                layer.bindPopup(formatPopupContent(feature.properties, 'Cycle Lane'));
                                attachFeedbackClickHandler(layer, feature);
                            }
                        }).addTo(map);
                        document.getElementById('toggleLanes').checked = true;
                    }
                    
                    fitMapToAllLayers();
                    updateStats();
                    updateFilterPanel();
                    
                } catch (err) {
                    alert('Error parsing GeoJSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        function addCustomLayer() {
            const fileInput = document.getElementById('customLayerFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a GeoJSON file');
                return;
            }
            
            const layerName = document.getElementById('layerName').value || file.name.replace('.geojson', '').replace('.json', '');
            const color = document.getElementById('layerColor').value;
            const geometryType = document.getElementById('layerType').value;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const geojson = JSON.parse(e.target.result);
                    const layerId = 'custom_' + (++layerIdCounter);
                    
                    const detectedType = geometryType === 'auto' ? detectGeometryType(geojson) : geometryType;
                    const layer = createLayerFromGeoJSON(geojson, color, detectedType, layerName);
                    layer.addTo(map);
                    
                    customLayers[layerId] = {
                        name: layerName,
                        color: color,
                        layer: layer,
                        data: geojson,
                        filteredData: geojson,
                        geometryType: detectedType,
                        visible: true,
                        filters: {}
                    };
                    
                    updateCustomLayersList();
                    updateCustomLegend();
                    fitMapToAllLayers();
                    updateStats();
                    updateFilterPanel();
                    
                    fileInput.value = '';
                    document.getElementById('layerName').value = '';
                    
                } catch (err) {
                    alert('Error parsing GeoJSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        function toggleCoreLayer(type) {
            if (coreLayers[type].layer) {
                const checkbox = document.getElementById(type === 'paths' ? 'togglePaths' : 'toggleLanes');
                if (checkbox.checked) {
                    map.addLayer(coreLayers[type].layer);
                } else {
                    map.removeLayer(coreLayers[type].layer);
                }
            }
        }
        
        function toggleCustomLayer(layerId) {
            const layerInfo = customLayers[layerId];
            if (layerInfo) {
                if (layerInfo.visible) {
                    map.removeLayer(layerInfo.layer);
                    layerInfo.visible = false;
                } else {
                    map.addLayer(layerInfo.layer);
                    layerInfo.visible = true;
                }
                updateCustomLayersList();
            }
        }
        
        function removeCustomLayer(layerId) {
            const layerInfo = customLayers[layerId];
            if (layerInfo) {
                map.removeLayer(layerInfo.layer);
                delete customLayers[layerId];
                updateCustomLayersList();
                updateCustomLegend();
                updateStats();
                updateFilterPanel();
            }
        }
        
        function updateCustomLayersList() {
            const container = document.getElementById('customLayersList');
            const layerIds = Object.keys(customLayers);
            
            if (layerIds.length === 0) {
                container.innerHTML = '<p style="color: #888; font-style: italic; font-size: 11px;">No custom layers added yet</p>';
                return;
            }
            
            let html = '';
            for (const layerId of layerIds) {
                const info = customLayers[layerId];
                const visibilityIcon = info.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
                html += `
                    <div class="custom-layer-item">
                        <div class="layer-info">
                            <div class="color-indicator" style="background: ${info.color};"></div>
                            <span class="layer-name" title="${info.name}">${info.name}</span>
                        </div>
                        <div class="layer-controls">
                            <button onclick="toggleCustomLayer('${layerId}')" title="Toggle visibility">${visibilityIcon}</button>
                            <button onclick="zoomToLayer('${layerId}')" title="Zoom to layer">üîç</button>
                            <button onclick="removeCustomLayer('${layerId}')" title="Remove layer">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }
            container.innerHTML = html;
        }
        
        function updateCustomLegend() {
            const container = document.getElementById('customLegend');
            const layerIds = Object.keys(customLayers);
            
            if (layerIds.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            let html = '<h3>Custom Layers</h3>';
            for (const layerId of layerIds) {
                const info = customLayers[layerId];
                const indicatorClass = info.geometryType === 'point' ? 'legend-point' : 'legend-line';
                html += `
                    <div class="legend-item">
                        <div class="${indicatorClass}" style="background: ${info.color};"></div>
                        <span>${info.name}</span>
                    </div>
                `;
            }
            container.innerHTML = html;
        }
        
        function zoomToLayer(layerId) {
            const layerInfo = customLayers[layerId];
            if (layerInfo && layerInfo.layer) {
                map.fitBounds(layerInfo.layer.getBounds(), { padding: [50, 50] });
            }
        }
        
        function fitMapToAllLayers() {
            const allLayers = [];
            
            if (coreLayers.paths.layer) allLayers.push(coreLayers.paths.layer);
            if (coreLayers.lanes.layer) allLayers.push(coreLayers.lanes.layer);
            
            for (const layerId of Object.keys(customLayers)) {
                if (customLayers[layerId].layer) {
                    allLayers.push(customLayers[layerId].layer);
                }
            }
            
            if (allLayers.length > 0) {
                const group = L.featureGroup(allLayers);
                map.fitBounds(group.getBounds(), { padding: [20, 20] });
            }
        }
        
        function updateStats() {
            let html = '<h4>üìä Statistics</h4>';
            
            if (coreLayers.paths.data) {
                const allFeatures = coreLayers.paths.data.features;
                const filteredFeatures = coreLayers.paths.filteredData?.features || allFeatures;
                const totalLength = filteredFeatures.reduce((sum, f) => sum + (f.properties.PATH_LENGTH || 0), 0);
                
                const typeCounts = {};
                filteredFeatures.forEach(f => {
                    const type = f.properties.ASSET_SUB_TYPE || 'Other';
                    typeCounts[type] = (typeCounts[type] || 0) + 1;
                });
                
                html += '<div style="margin-bottom: 10px;">';
                html += '<strong>Community Paths</strong>';
                html += `<div class="stat-row"><span>Showing:</span><span class="stat-value">${filteredFeatures.length} / ${allFeatures.length}</span></div>`;
                html += `<div class="stat-row"><span>Total length:</span><span class="stat-value">${(totalLength / 1000).toFixed(1)} km</span></div>`;
                html += '<details style="margin-top: 4px;"><summary style="font-size: 11px; cursor: pointer;">By type</summary>';
                html += '<div style="margin-top: 4px; font-size: 11px;">';
                for (const [type, count] of Object.entries(typeCounts).sort((a, b) => b[1] - a[1])) {
                    html += `<div class="stat-row"><span>${type}:</span><span>${count}</span></div>`;
                }
                html += '</div></details></div>';
            }
            
            if (coreLayers.lanes.data) {
                const allFeatures = coreLayers.lanes.data.features;
                const filteredFeatures = coreLayers.lanes.filteredData?.features || allFeatures;
                const totalLength = filteredFeatures.reduce((sum, f) => sum + (f.properties.LENGTH || 0), 0);
                
                const typeCounts = {};
                filteredFeatures.forEach(f => {
                    const type = f.properties.ASSET_SUB_TYPE || 'Other';
                    typeCounts[type] = (typeCounts[type] || 0) + 1;
                });
                
                html += '<div style="margin-bottom: 10px;">';
                html += '<strong>On Road Cycle Lanes</strong>';
                html += `<div class="stat-row"><span>Showing:</span><span class="stat-value">${filteredFeatures.length} / ${allFeatures.length}</span></div>`;
                html += `<div class="stat-row"><span>Total length:</span><span class="stat-value">${(totalLength / 1000).toFixed(1)} km</span></div>`;
                html += '<details style="margin-top: 4px;"><summary style="font-size: 11px; cursor: pointer;">By type</summary>';
                html += '<div style="margin-top: 4px; font-size: 11px;">';
                for (const [type, count] of Object.entries(typeCounts).sort((a, b) => b[1] - a[1])) {
                    html += `<div class="stat-row"><span>${type}:</span><span>${count}</span></div>`;
                }
                html += '</div></details></div>';
            }
            
            for (const layerId of Object.keys(customLayers)) {
                const info = customLayers[layerId];
                const allFeatures = info.data.features;
                const filteredFeatures = info.filteredData?.features || allFeatures;
                
                html += '<div style="margin-bottom: 10px;">';
                html += `<strong>${info.name}</strong>`;
                html += `<div class="stat-row"><span>Showing:</span><span class="stat-value">${filteredFeatures.length} / ${allFeatures.length}</span></div>`;
                html += `<div class="stat-row"><span>Geometry:</span><span>${info.geometryType}</span></div>`;
                html += '</div>';
            }
            
            if (!coreLayers.paths.data && !coreLayers.lanes.data && Object.keys(customLayers).length === 0) {
                html += '<p style="color: #888; font-style: italic;">Load data to see statistics</p>';
            }
            
            document.getElementById('stats').innerHTML = html;
        }
        
        function togglePanel() {
            const panel = document.getElementById('controlPanel');
            const btn = document.querySelector('.collapse-btn');
            panel.classList.toggle('collapsed');
            btn.classList.toggle('collapsed');
            btn.textContent = panel.classList.contains('collapsed') ? '‚ò∞ Show Panel' : '‚ò∞ Panel';
        }
        
        function toggleFilterPanel() {
            const panel = document.getElementById('filterPanel');
            const btn = document.getElementById('filterToggleBtn');
            panel.classList.toggle('collapsed');
            btn.classList.toggle('panel-open');
            btn.textContent = panel.classList.contains('collapsed') ? 'üîç Filters' : 'üîç Filters';
        }
        
        // ==================== LAYER STYLING ====================
        
        function toggleStylePanel() {
            const panel = document.getElementById('stylePanel');
            panel.classList.toggle('visible');
            if (panel.classList.contains('visible')) {
                updateStylePanel();
            }
        }
        
        function setBasemap(name) {
            // Remove current basemap
            if (currentBasemap && basemaps[currentBasemap]) {
                map.removeLayer(basemaps[currentBasemap]);
            }
            
            // Add new basemap
            if (basemaps[name]) {
                basemaps[name].addTo(map);
                basemaps[name].bringToBack();
            }
            
            currentBasemap = name;
            
            // Update UI
            document.querySelectorAll('.basemap-option').forEach(el => el.classList.remove('active'));
            document.getElementById('basemap-' + name)?.classList.add('active');
        }
        
        function updateStylePanel() {
            const container = document.getElementById('layerStylesList');
            let html = '';
            
            // Paths style section
            if (coreLayers.paths.data) {
                html += buildStyleSection('paths', 'Community Paths', layerStyles.paths, '#4CAF50');
            }
            
            // Lanes style section
            if (coreLayers.lanes.data) {
                html += buildStyleSection('lanes', 'Cycle Lanes', layerStyles.lanes, '#ff9800');
            }
            
            // Custom layers
            for (const [layerId, info] of Object.entries(customLayers)) {
                if (!customLayerStyles[layerId]) {
                    customLayerStyles[layerId] = {
                        color: info.color,
                        weight: info.geometryType === 'point' ? 2 : 3,
                        opacity: 0.8,
                        fillOpacity: 0.8,
                        radius: 6,
                        dashArray: '',
                        lineCap: 'round',
                        lineJoin: 'round'
                    };
                }
                html += buildStyleSection(layerId, info.name, customLayerStyles[layerId], info.color, info.geometryType);
            }
            
            if (!html) {
                html = '<p style="color: #888; font-style: italic; font-size: 11px; padding: 10px;">Load datasets to customize their styles</p>';
            }
            
            container.innerHTML = html;
        }
        
        function buildStyleSection(layerId, name, styles, defaultColor, geometryType = 'line') {
            const isPoint = geometryType === 'point';
            const isCustom = layerId.startsWith('custom_');
            
            let html = `<div class="style-section">
                <h4>
                    <span class="color-dot" style="background: ${styles.color || styles.singleColor || defaultColor};"></span>
                    ${name}
                </h4>`;
            
            // Color options
            if (!isCustom || isPoint) {
                html += `
                <div class="style-row">
                    <label>Color:</label>
                    <input type="color" value="${styles.color || styles.singleColor || defaultColor}" 
                        onchange="updateLayerStyle('${layerId}', 'color', this.value)">
                </div>`;
            } else {
                html += `
                <div class="style-row">
                    <label>Use type colors:</label>
                    <input type="checkbox" ${styles.useTypeColors ? 'checked' : ''} 
                        onchange="updateLayerStyle('${layerId}', 'useTypeColors', this.checked)">
                </div>
                <div class="style-row">
                    <label>Single color:</label>
                    <input type="color" value="${styles.singleColor || defaultColor}" 
                        onchange="updateLayerStyle('${layerId}', 'singleColor', this.value)"
                        ${styles.useTypeColors ? 'disabled' : ''}>
                </div>`;
            }
            
            // Line/stroke weight
            html += `
                <div class="style-row">
                    <label>${isPoint ? 'Border:' : 'Width:'}</label>
                    <input type="range" min="1" max="15" value="${styles.weight || 3}" 
                        oninput="document.getElementById('weight-val-${layerId}').textContent = this.value"
                        onchange="updateLayerStyle('${layerId}', 'weight', parseFloat(this.value))">
                    <span class="value-display" id="weight-val-${layerId}">${styles.weight || 3}</span>
                </div>`;
            
            // Opacity
            html += `
                <div class="style-row">
                    <label>Opacity:</label>
                    <input type="range" min="0.1" max="1" step="0.1" value="${styles.opacity || 0.8}" 
                        oninput="document.getElementById('opacity-val-${layerId}').textContent = (this.value * 100).toFixed(0) + '%'"
                        onchange="updateLayerStyle('${layerId}', 'opacity', parseFloat(this.value))">
                    <span class="value-display" id="opacity-val-${layerId}">${((styles.opacity || 0.8) * 100).toFixed(0)}%</span>
                </div>`;
            
            // Point-specific options
            if (isPoint) {
                html += `
                <div class="style-row">
                    <label>Size:</label>
                    <input type="range" min="3" max="20" value="${styles.radius || 6}" 
                        oninput="document.getElementById('radius-val-${layerId}').textContent = this.value"
                        onchange="updateLayerStyle('${layerId}', 'radius', parseFloat(this.value))">
                    <span class="value-display" id="radius-val-${layerId}">${styles.radius || 6}</span>
                </div>
                <div class="style-row">
                    <label>Fill opacity:</label>
                    <input type="range" min="0" max="1" step="0.1" value="${styles.fillOpacity || 0.8}" 
                        oninput="document.getElementById('fill-val-${layerId}').textContent = (this.value * 100).toFixed(0) + '%'"
                        onchange="updateLayerStyle('${layerId}', 'fillOpacity', parseFloat(this.value))">
                    <span class="value-display" id="fill-val-${layerId}">${((styles.fillOpacity || 0.8) * 100).toFixed(0)}%</span>
                </div>`;
            }
            
            // Line-specific options
            if (!isPoint) {
                html += `
                <div class="style-row">
                    <label>Dash pattern:</label>
                    <select onchange="updateLayerStyle('${layerId}', 'dashArray', this.value)">
                        <option value="" ${!styles.dashArray ? 'selected' : ''}>Solid</option>
                        <option value="5, 5" ${styles.dashArray === '5, 5' ? 'selected' : ''}>Dashed</option>
                        <option value="10, 10" ${styles.dashArray === '10, 10' ? 'selected' : ''}>Long dash</option>
                        <option value="2, 4" ${styles.dashArray === '2, 4' ? 'selected' : ''}>Dotted</option>
                        <option value="10, 5, 2, 5" ${styles.dashArray === '10, 5, 2, 5' ? 'selected' : ''}>Dash-dot</option>
                    </select>
                </div>
                <div class="style-row">
                    <label>Line cap:</label>
                    <select onchange="updateLayerStyle('${layerId}', 'lineCap', this.value)">
                        <option value="round" ${styles.lineCap === 'round' ? 'selected' : ''}>Round</option>
                        <option value="square" ${styles.lineCap === 'square' ? 'selected' : ''}>Square</option>
                        <option value="butt" ${styles.lineCap === 'butt' ? 'selected' : ''}>Butt</option>
                    </select>
                </div>`;
            }
            
            html += '</div>';
            return html;
        }
        
        function updateLayerStyle(layerId, property, value) {
            if (layerId === 'paths') {
                layerStyles.paths[property] = value;
            } else if (layerId === 'lanes') {
                layerStyles.lanes[property] = value;
            } else if (customLayerStyles[layerId]) {
                customLayerStyles[layerId][property] = value;
            }
        }
        
        function applyAllStyles() {
            // Apply to paths
            if (coreLayers.paths.layer) {
                applyPathsFilters();
            }
            
            // Apply to lanes
            if (coreLayers.lanes.layer) {
                applyLanesFilters();
            }
            
            // Apply to custom layers
            for (const layerId of Object.keys(customLayers)) {
                applyCustomLayerFilters(layerId);
            }
            
            updateStylePanel();
        }
        
        function resetAllStyles() {
            // Reset paths styles
            layerStyles.paths = {
                weight: 3,
                opacity: 0.8,
                dashArray: '',
                lineCap: 'round',
                lineJoin: 'round',
                useTypeColors: true,
                singleColor: '#e41a1c'
            };
            
            // Reset lanes styles
            layerStyles.lanes = {
                weight: 5,
                opacity: 0.9,
                dashArray: '',
                lineCap: 'round',
                lineJoin: 'round',
                useTypeColors: true,
                singleColor: '#ff7f00'
            };
            
            // Reset custom layer styles
            for (const [layerId, info] of Object.entries(customLayers)) {
                customLayerStyles[layerId] = {
                    color: info.color,
                    weight: info.geometryType === 'point' ? 2 : 3,
                    opacity: 0.8,
                    fillOpacity: 0.8,
                    radius: 6,
                    dashArray: '',
                    lineCap: 'round',
                    lineJoin: 'round'
                };
            }
            
            applyAllStyles();
        }
        
        function applyStylePreset(presetName) {
            const presets = {
                default: {
                    paths: { weight: 3, opacity: 0.8, dashArray: '', useTypeColors: true },
                    lanes: { weight: 5, opacity: 0.9, dashArray: '', useTypeColors: true },
                    custom: { weight: 3, opacity: 0.8, radius: 6, fillOpacity: 0.8 }
                },
                highContrast: {
                    paths: { weight: 4, opacity: 1, dashArray: '', useTypeColors: true },
                    lanes: { weight: 6, opacity: 1, dashArray: '', useTypeColors: true },
                    custom: { weight: 3, opacity: 1, radius: 8, fillOpacity: 1 }
                },
                subtle: {
                    paths: { weight: 2, opacity: 0.5, dashArray: '', useTypeColors: true },
                    lanes: { weight: 3, opacity: 0.5, dashArray: '', useTypeColors: true },
                    custom: { weight: 1, opacity: 0.5, radius: 4, fillOpacity: 0.5 }
                },
                thick: {
                    paths: { weight: 6, opacity: 0.8, dashArray: '', useTypeColors: true },
                    lanes: { weight: 8, opacity: 0.9, dashArray: '', useTypeColors: true },
                    custom: { weight: 4, opacity: 0.8, radius: 10, fillOpacity: 0.8 }
                },
                thin: {
                    paths: { weight: 1, opacity: 0.8, dashArray: '', useTypeColors: true },
                    lanes: { weight: 2, opacity: 0.9, dashArray: '', useTypeColors: true },
                    custom: { weight: 1, opacity: 0.8, radius: 4, fillOpacity: 0.8 }
                },
                neon: {
                    paths: { weight: 4, opacity: 1, dashArray: '', useTypeColors: false, singleColor: '#00ff88' },
                    lanes: { weight: 5, opacity: 1, dashArray: '', useTypeColors: false, singleColor: '#ff00ff' },
                    custom: { weight: 2, opacity: 1, radius: 8, fillOpacity: 1, color: '#00ffff' }
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            // Apply to paths
            Object.assign(layerStyles.paths, preset.paths);
            
            // Apply to lanes
            Object.assign(layerStyles.lanes, preset.lanes);
            
            // Apply to custom layers
            for (const layerId of Object.keys(customLayerStyles)) {
                Object.assign(customLayerStyles[layerId], preset.custom);
            }
            
            applyAllStyles();
        }
        
        function getLayerStyle(layerId, feature) {
            // Check if filter-based coloring is enabled
            const filterColor = getFeatureColorByFilter(layerId, feature);
            
            if (layerId === 'paths') {
                const styles = layerStyles.paths;
                let color;
                if (filterColor) {
                    color = filterColor;
                } else if (styles.useTypeColors) {
                    color = getPathColor(feature?.properties?.ASSET_SUB_TYPE);
                } else {
                    color = styles.singleColor;
                }
                return {
                    color: color,
                    weight: styles.weight,
                    opacity: styles.opacity,
                    dashArray: styles.dashArray,
                    lineCap: styles.lineCap,
                    lineJoin: styles.lineJoin
                };
            } else if (layerId === 'lanes') {
                const styles = layerStyles.lanes;
                let color;
                if (filterColor) {
                    color = filterColor;
                } else if (styles.useTypeColors) {
                    color = getLaneColor(feature?.properties?.ASSET_SUB_TYPE);
                } else {
                    color = styles.singleColor;
                }
                return {
                    color: color,
                    weight: styles.weight,
                    opacity: styles.opacity,
                    dashArray: styles.dashArray,
                    lineCap: styles.lineCap,
                    lineJoin: styles.lineJoin
                };
            } else if (customLayerStyles[layerId]) {
                const styles = customLayerStyles[layerId];
                return {
                    ...styles,
                    color: filterColor || styles.color
                };
            }
            return {};
        }
        
        // ==================== END LAYER STYLING ====================
    </script>
</body>
</html>
